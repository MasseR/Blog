---
title: The importance of good git patterns
tags:  git
---

With the project I'm currently working on, we have over 3000 commits in the git
repository. The project is relatively old now and due to its age and my
simple-mindedness at the beginning, the state of the repository has had a rough
start.

It was our first project to use git and it was up to me to teach my coworkers
to use git. I have used git every single of my projects for many years now, but
most of my projects are small compared. It lead to the situation where we
mostly used only master branch, commit sizes ranged from typos to days of work.
Some commits were broken, without any kind of testing. We used different
editors where some used tabs for indenting and some used spaces. Conflicts were
abound because of whitespace issues. I still haven't trained my vim to not to
leave ending whitespace when doing `gq`.

Somewhere between the 1000 and 2000 commits I decided that we needed some sort
of control over git. I wrote a simple style guide for commits and branching,
which while very basic and simplistic, has helped us a lot.

- Small meaningful commits
 - If you spent two days writing code without committing, it's too long
 - If you spent 30 seconds writing code, it's too small
 - It's highly situation dependant, those are by no means any hard limits. Use
   your judgement on what is a small enough thing to commit.
- Don't commit broken code
 - Nobody is perfect, broken code will be committed, but if you can prevent it,
   please do.
- Don't pollute the main branches
 - Keep features on a separate branch. Git has a nice lightweight branching
   model making it feasible to have separate branches for features and
   bugfixes.
- Have separate branches for development, feature freezes, release candidates
  and production
  - Create bugfix branches from the earliest branch if possible. This allows
    you to fix bugs without possibly bringing volatile code to earlier
    branches.
- Don't put autogenerated code to the repository
 - It's automatically generated, it can always be regenerated.
 - If you still stage it, make sure to stage it as rarely as possible. For
   example generate the translations when going to featurefreeze and provide
   the translations files to translators.

Git bisect is your friend. It's demanding, but when your repository is in a
good enough state, it can really save you hours of work. In a recent situation,
some less frequently (but still important) part of the page stopped working.
Visually it was alright so we had no idea how long it had been broken. It was
part of a feature we had been writing for many weeks, even taking a break from
the feature while doing something else. I had merged the other features by this
point and there were probably hundreds of commits between the last working
commit and the current head.

What do you do in this situation? You could start debugging, but it's probable
that you have no idea where to start, or at least what might have caused it.
You could spend hours debugging it even if the fix is a simple one-line fix.
It's annoying especially when you know it was working before. If you have had
small meaningful commits you can go back in time to see what commit broke it
and then deduce from those changes what might have borked it. But it's tenuous
to go through each commit one by one and see whether it works or not and here
is where git bisect comes into play. Git bisect uses simple binary search to
search through your commits to find the offending commit. Because it's binary
search, it's $O(log n)$, meaning that if you have 10 commits between you, you
only need to check $log 10 = 2.3$ commits, and even if you have 100 commits
between, it's still only $log 100 = 4.6$ commits.

So why are good git habits important? Imagine that you have a bad commit
somewhere that prevents you from testing the broken feature. For example,
something visual is broken, but you get error 500. Now imagine also that the
error persists through many commits. This is possible when you have had feature
branches, but you have merged them back badly and haven't tested the conflicts
properly. Now if you do git bisect and hit into a irrelated broken commit, you
need to run `git bisect skip`, which moves the pointer to 'somewhere' (I don't
know where), and suddenly your 6 testable commits have changed into 20. If you
are in a bad luck, after finishing bisect, you can get multiple bad commits if
git can't figure out which of the skipped commits is the offending commit.
Suddenly your 5 minutes of bisecting has turned into 30 minutes of bisecting
and finding the offending commit.

I'm thinking that I should add a new bullet point to the previous list, 'test
your code after merges'. Merges and especially merge conflicts can be a bane.
With good automated tests you can quickly see whether something has broken
during that time. Even if you are the only one writing tests, don't let it up
and don't let the tests bitrot. I can't accentuate this enough, tests can save
you hours of debugging.
